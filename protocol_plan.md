# Centralized WebSocket Protocol Management Plan

**Status:** Proposed
**Date:** 2025-06-13
**Author:** Code Analyst

## 1. Overview & Goal

The project currently defines WebSocket message structures independently in both the Python backend (`agents` service) and the TypeScript frontend (`homepage`). This manual synchronization is error-prone and leads to protocol drift, causing bugs and increasing maintenance overhead.

The goal of this plan is to establish a **Single Source of Truth** for the WebSocket protocol. We will define the protocol schema in one language, automatically generate the corresponding models for the other, and place them in a shared location. This will ensure that the frontend and backend are always in sync, providing strong typing and validation from end to end.

## 2. Problem Statement

*   **Protocol Drift:** Any change to a message structure must be manually replicated in both the frontend and backend. It's easy to forget a field or introduce a type mismatch.
*   **No Contract:** There is no formal contract between the client and server. Developers must visually inspect code in two different languages to understand the protocol.
*   **Brittle Communication:** Mismatches often lead to silent failures or runtime errors that are difficult to debug (e.g., a message is dropped, or a field is unexpectedly `undefined`).
*   **Development Overhead:** Onboarding new developers is slower, as they must learn the protocol from two separate, unsynchronized sources.

<!-- (Message-shape drift bullet removed; now addressed by models) -->

## 3. Proposed Solution

We will adopt a **Python-first, code-generation** approach. The protocol will be defined using Pydantic models within the Python ecosystem. These models will then be used to generate TypeScript interfaces for the frontend. The Pydantic models are the single source of truth, replacing any manually maintained tables or documentation.

## 4. Implementation Plan

### Phase 1: Setup and Initial Model Definition

1.  **Directory Structure:** The plan is to create the directory structure as outlined above within `shared/protocol/`.
2.  **Install Tooling:** A modern version of the generator, like `pydantic-to-typescript>=2.2`, should be added to `shared/setup.py`. This is compatible with Pydantic v2.7+. This step is outside the scope of this plan update.
3.  **Define Core Models:** In `shared/protocol/models.py`, define the message structures to match the existing nested format (`{"type": "...", "data": {...}}`).

    *Example (`models.py`):*
    ```python
    from pydantic import BaseModel, Field
    from typing import Literal, Union, Optional, Annotated

    # --- Payloads for the 'data' field of nested messages ---
    class StartConversationData(BaseModel):
        workflow: str
        merchant_id: Optional[str] = None
        scenario_id: Optional[str] = None

    class DebugRequestData(BaseModel):
        debug_type: Literal["snapshot", "session", "state", "metrics", "prompts"]

    # --- Top-level message models ---
    # Note: Some messages are flat, others have a nested `data` object.
    # This matches the existing backend implementation.
    class StartConversationMessage(BaseModel):
        type: Literal["start_conversation"]
        data: StartConversationData

    class UserMessage(BaseModel):
        type: Literal["message"]
        text: str  # This message type is flat

    class DebugRequestMessage(BaseModel):
        type: Literal["debug_request"]
        data: DebugRequestData

    # --- Discriminated Union for all Incoming Messages ---
    # Pydantic will use the `type` field to determine which model to use for validation.
    IncomingMessage = Annotated[
        Union[
            StartConversationMessage,
            UserMessage,
            DebugRequestMessage,
        ],
        Field(discriminator="type"),
    ]
    ```
4.  **Generation Script:** The generation script will be `shared/protocol/generate_ts.py`.

    *Example (`generate_ts.py`):*
    ```python
    #!/usr/bin/env python3
    import sys
    from pathlib import Path
    from pydantic_to_typescript import generate_typescript_defs

    # Add monorepo root to sys.path to allow for module imports
    repo_root = Path(__file__).parent.parent.parent
    if str(repo_root) not in sys.path:
        sys.path.insert(0, str(repo_root))

    # Use a module import string (e.g., 'shared.protocol.models'), not a file path.
    py_module_name = "shared.protocol.models"
    ts_output_path = repo_root / "shared/protocol/generated/ts/index.ts"

    # Ensure output directory exists
    ts_output_path.parent.mkdir(parents=True, exist_ok=True)
    
    header = "//\n// DO NOT EDIT. THIS FILE IS AUTO-GENERATED BY `pydantic-to-typescript`\n//\n"

    # Generate the file content first
    ts_defs = generate_typescript_defs(
        py_module_name, 
        json_dump_kwargs={'indent': 2}
    )

    # Write header and content to file
    with open(ts_output_path, 'w') as f:
        f.write(header)
        f.write(ts_defs)

    print(f"âœ… TypeScript models generated at {ts_output_path}")
    ```

### Phase 2: Backend Integration

1.  **Modify `agents` service:** Update `agents/app/platforms/web/websocket_handler.py` (and its sub-handlers) to use the new models.
2.  **Update Python Imports:** Since `shared` is already in the `PYTHONPATH` for services, you can import the models directly.
3.  **Type WebSocket Messages:** In the `handle_connection` loop, parse the incoming JSON into the `IncomingMessage` model. This provides automatic, type-safe validation.

    *Before:*
    ```python
    async for message in websocket.iter_json():
        message_type = message.get("type", "message")
        # ... manual parsing and validation ...
    ```

    *After:*
    ```python
    from shared.protocol.models import IncomingMessage
    from pydantic import ValidationError

    async for raw_message in websocket.iter_json():
        try:
            # Pydantic validates the entire message structure, including the nested data object.
            message = IncomingMessage.model_validate(raw_message)
            
            # The existing routing logic can remain for now.
            # We are just adding a validation layer.
            message_type = message.type
            handler_method = getattr(self.message_handlers, f"handle_{message_type}", None)
            
            if handler_method:
                # Pass the validated dict to the handler for maximum compatibility
                # with existing handler function signatures.
                await handler_method(websocket, conversation_id, message.model_dump())
            else:
                logger.warning(f"No handler for message type: {message_type}")

        except ValidationError as e:
            # Pydantic raises an error for invalid message structures
            await self.platform.send_error(websocket, f"Invalid message format: {e.errors()}")
    ```

### Phase 3: Frontend Integration

1.  **Run Generator:** Execute `python shared/protocol/generate_ts.py` from the repository root.
2.  **Verify Output:** Check `shared/protocol/generated/ts/index.ts` to ensure the TypeScript interfaces were generated correctly.
3.  **Update `homepage`:** Refactor frontend code to use these shared types.
4.  **Modify `useWebSocketChat.ts`:** Replace locally-defined interfaces with imported types from `../../../shared/protocol/generated/ts`.
5.  **Type `sendMessage`:** Ensure that the `sendMessage` function and other message construction logic builds objects that conform to the new, stricter interfaces (e.g., `StartConversationMessage`). This will immediately catch bugs where incorrect fields are being sent.

### Phase 4: Expansion and Finalization

1.  **Migrate All Payloads:** Systematically convert every single message type (`cj_message`, `fact_check_complete`, `error`, etc.) into Pydantic models in `shared/protocol/models.py`. This includes client-bound messages as well for full-protocol coverage.
2.  **Regenerate:** Run the generation script again.
3.  **Refactor:** Update the backend and frontend code that produces or consumes these messages to use the new typed models.
4.  **CI/CD Integration:** This is a critical step to prevent future drift. See section 6.

## 5. New Developer Workflow

When a developer needs to change the WebSocket protocol (e.g., add a field to a message):

1.  **Edit Python:** They modify the Pydantic model in `shared/protocol/models.py`.
2.  **Run Script:** They run `python shared/protocol/generate_ts.py` from the root directory.
3.  **Commit Both:** They commit the changes to **both** the Python model and the auto-generated TypeScript file.
4.  **Update Logic:** They update the relevant Python and TypeScript code to utilize the new field(s). The TypeScript compiler and Pydantic validators will guide them.

## 6. Risks & Mitigations

*   **Risk:** Developers forget to run the generation script, causing the committed code to be out of sync.
    *   **Mitigation:** **Implement a CI Check.** Add a step to the CI pipeline that runs `python shared/protocol/generate_ts.py` and then uses `git diff --exit-code shared/protocol/generated/ts/index.ts`. If there's a diff, it means the generated file is stale, and the build fails. This forces developers to commit the up-to-date version. A pre-commit hook can also be used for local development.

*   **Risk:** The `pydantic-to-typescript` tool might not support a complex type we need.
    *   **Mitigation:** Keep the protocol models simple and focused on data transfer. Avoid complex custom types in the Pydantic models destined for generation. Test complex cases early.

*   **Risk:** Initial refactoring effort is significant.
    *   **Mitigation:** The phased implementation plan is designed to manage this. We can start with just one or two message types to prove the workflow and then incrementally migrate the rest.
