# Ngrok Integration Plan for HireCJ

## Overview

This plan extends the auth service's proven tunnel detection pattern to all services, providing:
- Automatic tunnel URL detection (no manual copying)
- HTTPS everywhere (matching production)
- Proper CORS configuration (replacing wildcards)
- Support for reserved domains and free tier

## Current State

- **Auth service** already has working tunnel detection
- **Other services** use CORS wildcards (`"*"`) and manual configuration
- **All services** use environment variables and Pydantic settings

## Implementation Phases

### Phase 1: Prerequisites and Basic Setup (15 minutes)

#### 1.1 Create Ngrok Configuration Files

**Create `ngrok.yml.amir`** (for reserved domains):
```yaml
version: "2"
authtoken: ${NGROK_AUTHTOKEN}

tunnels:
  homepage:
    proto: http
    addr: 3456
    hostname: amir.hirecj.ai
    
  auth:
    proto: http
    addr: 8103
    hostname: amir-auth.hirecj.ai
    
  agents:
    proto: http
    addr: 8000
    
  database:
    proto: http
    addr: 8002
    
  knowledge:
    proto: http
    addr: 8001
```

**Create `ngrok.yml.example`** (for other developers):
```yaml
version: "2"
authtoken: ${NGROK_AUTHTOKEN}

tunnels:
  homepage:
    proto: http
    addr: 3456
    
  auth:
    proto: http
    addr: 8103
    
  agents:
    proto: http
    addr: 8000
    
  database:
    proto: http
    addr: 8002
    
  knowledge:
    proto: http
    addr: 8001
```

#### 1.2 Update .gitignore

Add to root `.gitignore`:
```gitignore
# Ngrok
ngrok.yml
.env.tunnel
*/.env.tunnel
```

#### 1.3 Update Makefile

Add these commands to the root `Makefile`:
```makefile
# Tunnel management
tunnels:
	@echo "🌐 Starting ngrok tunnels..."
	@if [ ! -f ngrok.yml ]; then \
		echo "Creating ngrok.yml from template..."; \
		cp ngrok.yml.example ngrok.yml; \
	fi
	@echo "Starting ngrok (this will block - use Ctrl+C to stop)..."
	@echo ""
	ngrok start --all --config ngrok.yml

# Detect tunnels (run in separate terminal)
detect-tunnels:
	@echo "🔍 Detecting tunnel URLs..."
	@python shared/detect_tunnels.py

# Development with tunnels (recommended workflow)
dev-tunnels:
	@echo "🚀 Development with tunnels:"
	@echo ""
	@echo "1. Terminal 1: make tunnels"
	@echo "2. Terminal 2: make detect-tunnels" 
	@echo "3. Terminal 3: make dev-all"
	@echo ""
	@echo "Or use tmux: make dev-tunnels-tmux"

# All-in-one with tmux
dev-tunnels-tmux:
	@command -v tmux >/dev/null 2>&1 || { echo "tmux required: brew install tmux"; exit 1; }
	@tmux new-session -d -s hirecj-tunnels
	@tmux send-keys -t hirecj-tunnels:0 'make tunnels' C-m
	@tmux new-window -t hirecj-tunnels:1 -n detect
	@tmux send-keys -t hirecj-tunnels:1 'sleep 5 && make detect-tunnels && echo "✅ Tunnels configured!"' C-m
	@tmux new-window -t hirecj-tunnels:2 -n services  
	@tmux send-keys -t hirecj-tunnels:2 'sleep 8 && make dev-all' C-m
	@tmux attach -t hirecj-tunnels
```

### Phase 2: Create Shared Tunnel Detection (20 minutes)

#### 2.1 Create Tunnel Detector Script

**Create `shared/detect_tunnels.py`**:
```python
#!/usr/bin/env python3
"""Detect all running ngrok tunnels and write .env.tunnel files for each service."""

import json
import time
import httpx
import sys
from pathlib import Path
from typing import Dict, Optional

# Service to port mapping
SERVICES = {
    "homepage": 3456,
    "auth": 8103,
    "agents": 8000,
    "database": 8002,
    "knowledge": 8001,
}

def get_tunnels() -> Dict[int, str]:
    """Get all tunnels indexed by local port."""
    try:
        response = httpx.get("http://localhost:4040/api/tunnels", timeout=2.0)
        if response.status_code == 200:
            data = response.json()
            tunnels = {}
            
            for tunnel in data.get("tunnels", []):
                if tunnel.get("proto") == "https":
                    # Extract port from config
                    addr = tunnel.get("config", {}).get("addr", "")
                    if ":" in addr:
                        port = int(addr.split(":")[-1])
                        tunnels[port] = tunnel.get("public_url")
            
            return tunnels
    except Exception as e:
        print(f"❌ Error fetching tunnels: {e}", file=sys.stderr)
    
    return {}

def write_tunnel_env(service: str, tunnel_url: str):
    """Write tunnel URL to service's .env.tunnel file."""
    env_file = Path(service) / ".env.tunnel"
    env_file.parent.mkdir(exist_ok=True)
    
    with open(env_file, "w") as f:
        f.write(f"# Auto-generated by tunnel detector\n")
        f.write(f"# This file is gitignored and regenerated on each run\n")
        f.write(f"PUBLIC_URL={tunnel_url}\n")
        
        # Service-specific additions
        if service == "auth":
            f.write(f"OAUTH_REDIRECT_BASE_URL={tunnel_url}\n")
        elif service == "homepage":
            f.write(f"VITE_PUBLIC_URL={tunnel_url}\n")

def main():
    """Detect and configure all service tunnels."""
    print("🔍 Detecting ngrok tunnels...", file=sys.stderr)
    
    # Wait for ngrok to start
    for attempt in range(10):
        tunnels = get_tunnels()
        if tunnels:
            break
        time.sleep(1)
    
    if not tunnels:
        print("❌ No tunnels detected", file=sys.stderr)
        return 1
    
    # Write .env.tunnel for each service
    configured = []
    for service, port in SERVICES.items():
        if port in tunnels:
            tunnel_url = tunnels[port]
            write_tunnel_env(service, tunnel_url)
            configured.append(f"  {service}: {tunnel_url}")
            print(f"✅ {service}: {tunnel_url}", file=sys.stderr)
    
    # Also write a root .env.tunnel with all URLs for reference
    with open(".env.tunnel", "w") as f:
        f.write("# All detected tunnel URLs\n")
        for service, port in SERVICES.items():
            if port in tunnels:
                url_var = f"{service.upper()}_URL"
                f.write(f"{url_var}={tunnels[port]}\n")
    
    print("\n📋 Summary:", file=sys.stderr)
    print("\n".join(configured), file=sys.stderr)
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
```

#### 2.2 Make Script Executable

```bash
chmod +x shared/detect_tunnels.py
```

### Phase 3: Update Service Configurations (30 minutes)

#### 3.1 Update Python Service Configs

For each Python service (`agents`, `database`, `knowledge`), update `app/config.py`:

**Add to imports**:
```python
from pathlib import Path
```

**Add these fields to the Settings class**:
```python
# Public URL Configuration
public_url: str = Field("", env="PUBLIC_URL")
frontend_url: str = Field("http://localhost:3456", env="FRONTEND_URL")
auth_url: str = Field("http://localhost:8103", env="AUTH_URL")

@field_validator("public_url", mode="before")
@classmethod
def detect_tunnel_url(cls, v: Optional[str]) -> str:
    """Auto-detect tunnel URL from .env.tunnel if not set."""
    if v:
        return v
    
    tunnel_env_path = Path(".env.tunnel")
    if tunnel_env_path.exists():
        try:
            with open(tunnel_env_path) as f:
                for line in f:
                    if line.startswith("PUBLIC_URL="):
                        tunnel_url = line.split("=", 1)[1].strip()
                        if tunnel_url:
                            logger.info(f"📡 Using detected tunnel URL: {tunnel_url}")
                            return tunnel_url
        except Exception:
            pass
    
    # Return service-specific default
    return f"http://localhost:{settings.app_port}"
```

#### 3.2 Fix CORS Configuration

Update each Python service's `main.py`:

**Replace the CORS middleware setup**:
```python
# Build allowed origins from configuration
allowed_origins = [
    settings.frontend_url,
    settings.auth_url,
    # Always allow localhost for development
    "http://localhost:3456",
    "http://localhost:8000", 
    "http://localhost:8103",
    "http://localhost:8002",
]

# Add public URLs if configured
if settings.public_url:
    allowed_origins.append(settings.public_url)

# Add reserved domains if detected
if "hirecj.ai" in settings.frontend_url:
    allowed_origins.extend([
        "https://amir.hirecj.ai",
        "https://amir-auth.hirecj.ai",
    ])

# Remove duplicates and empty strings
allowed_origins = list(set(filter(None, allowed_origins)))

app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

#### 3.3 Update Homepage Configuration

**Update `homepage/vite.config.ts`**:
```typescript
import { defineConfig, loadEnv } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path'

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '')
  const isNgrok = env.VITE_PUBLIC_URL?.includes('ngrok') || env.VITE_PUBLIC_URL?.includes('hirecj.ai')
  
  return {
    plugins: [react()],
    server: {
      port: 3456,
      host: true,
      // Fix HMR for ngrok
      hmr: isNgrok ? {
        protocol: 'wss',
        host: new URL(env.VITE_PUBLIC_URL || 'http://localhost:3456').hostname,
        clientPort: 443
      } : true
    },
    resolve: {
      alias: {
        '@': path.resolve(__dirname, './src'),
      },
    },
  }
})
```

**Update API configuration in homepage** to read from environment:
```typescript
// Add to API client configuration
const headers = {
  'ngrok-skip-browser-warning': 'true',
  // ... other headers
}
```

### Phase 4: Testing and Validation (15 minutes)

#### 4.1 Test the Setup

1. **Start tunnels** (Terminal 1):
   ```bash
   make tunnels
   ```

2. **Detect tunnels** (Terminal 2):
   ```bash
   make detect-tunnels
   ```

3. **Verify detection**:
   ```bash
   # Check root summary
   cat .env.tunnel
   
   # Check service-specific files
   cat agents/.env.tunnel
   cat auth/.env.tunnel
   ```

4. **Start services** (Terminal 3):
   ```bash
   make dev-all
   ```

#### 4.2 Validate CORS

1. Open browser developer tools
2. Navigate to your homepage tunnel URL
3. Check Network tab for API calls
4. Verify no CORS errors in console

#### 4.3 Test Service Communication

1. **Test Auth OAuth flow**:
   - Should redirect to tunnel URL, not localhost
   
2. **Test WebSocket connection**:
   - Should connect via WSS to tunnel URL
   
3. **Test API calls**:
   - All should use HTTPS tunnel URLs

## Developer Workflows

### For Amir (with reserved domains)

```bash
# One-time setup
cp ngrok.yml.amir ngrok.yml
export NGROK_AUTHTOKEN=your_token_here

# Daily development (one command)
make dev-tunnels-tmux

# Your URLs:
# - https://amir.hirecj.ai (homepage)
# - https://amir-auth.hirecj.ai (auth)
# - https://[random].ngrok-free.app (other services)
```

### For Other Developers

```bash
# One-time setup
brew install ngrok
ngrok config add-authtoken YOUR_TOKEN
cp ngrok.yml.example ngrok.yml

# Daily development
make dev-tunnels-tmux

# All services get random ngrok URLs
# URLs are auto-detected - no manual configuration needed
```

## Troubleshooting

### Common Issues

1. **"Tunnel URL header not found"**
   - Already handled by adding `ngrok-skip-browser-warning` header

2. **CORS errors**
   - Check service logs for allowed origins list
   - Ensure `make detect-tunnels` ran successfully
   - Restart services after tunnel detection

3. **HMR not working (homepage)**
   - vite.config.ts changes should fix this
   - Check browser console for WebSocket errors

4. **Tunnel detection fails**
   - Ensure ngrok is running: `curl http://localhost:4040/api/tunnels`
   - Check ngrok dashboard: http://localhost:4040

### Debug Commands

```bash
# Check if ngrok is running
curl http://localhost:4040/api/tunnels | jq

# Check detected URLs
cat .env.tunnel

# Check service logs
make logs-agents
```

## Benefits

✅ **Automatic Configuration** - No manual URL copying  
✅ **Extends Proven Pattern** - Uses auth's existing tunnel detection  
✅ **Secure CORS** - No more wildcards  
✅ **HTTPS Everywhere** - Matches production  
✅ **Simple Workflow** - One command starts everything  
✅ **Reserved Domains** - Consistent URLs for Amir  
✅ **Free Tier Friendly** - Works with random URLs  

## Production Parity

This setup mirrors production:
- HTTPS everywhere (via ngrok SSL)
- Multiple domains per service
- Proper CORS configuration
- Environment-based settings
- No hardcoded localhost URLs

The implementation maintains the same code between development and production!